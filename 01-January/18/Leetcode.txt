1895. Largest Magic Square
A k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square.

Given an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.
_______________________________________________________

Code :
class Solution {
    public int largestMagicSquare(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        if (n < 2 || m < 2) return 1;

        long[][] row = new long[n][m + 1];
        long[][] col = new long[n + 1][m];
        long[][] d1 = new long[n + 1][m + 2];
        long[][] d2 = new long[n + 1][m + 2];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                row[i][j + 1] = row[i][j] + grid[i][j];
                col[i + 1][j] = col[i][j] + grid[i][j];
                d1[i + 1][j + 1] = d1[i][j] + grid[i][j];
                d2[i + 1][j] = d2[i][j + 1] + grid[i][j];
            }
        }

        for (int k = Math.min(n, m); k > 1; k--) {
            for (int r = 0; r <= n - k; r++) {
                for (int c = 0; c <= m - k; c++) {
                    long target = row[r][c + k] - row[r][c];

                    if (d1[r + k][c + k] - d1[r][c] != target) continue;
                    if (d2[r + k][c] - d2[r][c + k] != target) continue;

                    boolean match = true;
                    for (int i = 0; i < k; i++) {
                        if (row[r + i][c + k] - row[r + i][c] != target) {
                            match = false;
                            break;
                        }
                    }
                    if (!match) continue;

                    for (int j = 0; j < k; j++) {
                        if (col[r + k][c + j] - col[r][c + j] != target) {
                            match = false;
                            break;
                        }
                    }

                    if (match) return k;
                }
            }
        }
        return 1;
    }
}
_______________________________________________________

Intuition :
The task is to find the largest magic square, where all rows, columns, and both diagonals have the same sum. A brute-force approach would repeatedly recompute sums for each candidate square, which is inefficient.

To optimize, prefix sums can be used to compute row and column sums in constant time. To further improve performance and avoid repeatedly iterating over diagonals, diagonal prefix sums are also precomputed. This allows all required sums rows, columns, and diagonals to be checked efficiently. By validating diagonals first, we can quickly discard most invalid squares and significantly speed up the average case.
_______________________________________________________

Approach :
Precompute four prefix sum matrices:
row[i][j]: sum of elements in row i up to column j.
col[i][j]: sum of elements in column j up to row i.
d1[i][j]: sum along the main diagonal.
d2[i][j]: sum along the anti-diagonal.

Iterate over possible square sizes k from largest to smallest.

For each possible top-left position (r, c) of a k × k square:
Compute the target sum using the first row.
Check both diagonals in O(1) using diagonal prefix sums (fail fast).
If diagonals match, check all rows and columns using row and column prefix sums.

Return the first valid k found, as it is guaranteed to be the largest.
If no valid square of size ≥ 2 is found, return 1.
_______________________________________________________

Complexity :
Time complexity: O(m⋅n⋅min(m,n))
Space complexity: O(m⋅n)
