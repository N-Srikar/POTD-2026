K Sized Subarray Maximum
Given an array arr[] of positive integers and an integer k. You have to find the maximum value for each contiguous subarray of size k. Return an array of maximum values corresponding to each contiguous subarray.
______________________________________________________

Code :
class Solution {
    public ArrayList<Integer> maxOfSubarrays(int[] arr, int k) {
        ArrayList<Integer> result = new ArrayList<>();
        Deque<Integer> dq = new ArrayDeque<>();

        for (int i = 0; i < arr.length; i++) {
            while (!dq.isEmpty() && dq.peekFirst() <= i - k) {
                dq.pollFirst();
            }

            while (!dq.isEmpty() && arr[dq.peekLast()] <= arr[i]) {
                dq.pollLast();
            }

            dq.offerLast(i);

            if (i >= k - 1) {
                result.add(arr[dq.peekFirst()]);
            }
        }

        return result;
    }
}
_______________________________________________________

Intuition :
For every contiguous subarray of size k, we need the maximum element.
Recomputing the maximum for each window by scanning all k elements would be inefficient.

To optimize this, we maintain a structure that:
Always keeps track of useful elements for the current window.
Allows us to get the maximum in constant time.

A deque (double-ended queue) is ideal because it lets us efficiently add and remove elements from both ends while maintaining order.
_______________________________________________________

Approach :
Use a deque to store indices of array elements.

Maintain the deque such that:
Elements are stored in decreasing order of values.
The front of the deque always contains the index of the maximum element for the current window.

Traverse the array:
Remove indices from the front if they are out of the current window.
Remove indices from the back if their corresponding values are less than or equal to the current element.
Add the current index to the back of the deque.

Once the first window of size k is formed:
Add arr[deque.front] to the result list.

Continue until all windows are processed.
_______________________________________________________

Complexity :
Time Complexity: O(n)
Space Complexity: O(k)