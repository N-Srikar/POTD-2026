868. Binary Gap
Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.

Two 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in "1001" have a distance of 3.
_______________________________________________________

Code :
class Solution {
    public int binaryGap(int N) {
        int indexOne = -1, longestDistance = 0;
        for (int i = 0; i < 32; ++i) { 
            if (((N >> i) & 1) == 1) { 
                if (indexOne != -1)
                    longestDistance = Math.max(longestDistance, i - indexOne);
                indexOne = i;
            }
        }

        return longestDistance;
    }
}
_______________________________________________________

Intuition :
We need to find the maximum distance between two consecutive 1s in the binary representation of a number.
Instead of converting the number to a binary string, we can directly examine each bit using bitwise operations.

As we scan through the bits from least significant to most significant:
Whenever we encounter a 1, we compare its position with the previous 1.
The difference between their positions gives the distance.
We keep track of the maximum such distance.

If there are fewer than two 1s, the answer is 0.
_______________________________________________________

Approach :
Initialize:
indexOne = -1 → stores the position of the last seen 1.
longestDistance = 0 → stores the maximum gap found.

Loop through bit positions from 0 to 31:
Check if the ith bit is 1 using:
(N >> i) & 1
If it is 1:
If indexOne is not -1, compute the distance i - indexOne.
Update longestDistance with the maximum value.
Update indexOne = i.

Return longestDistance.
_______________________________________________________

Complexity :
Time complexity: O(1)
Space complexity: O(1)