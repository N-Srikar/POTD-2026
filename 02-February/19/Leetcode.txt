696. Count Binary Substrings
Given a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.
_______________________________________________________

Code :
class Solution {
    public int countBinarySubstrings(String s) {
        int res = 0, prev = 0, strk = 1;

        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) strk++;
            else {
                prev = strk;
                strk = 1;
            }
            if (strk <= prev) res++;
        }
        return res;
    }
}
_______________________________________________________

Intuition :
A valid substring must satisfy two conditions:
It contains equal numbers of 0s and 1s.
All 0s are grouped together and all 1s are grouped together.

This means every valid substring looks like: "000111", "01", "1100", etc.

So instead of checking every substring, we observe a key pattern:
If we group consecutive identical characters, the number of valid substrings between two adjacent groups depends only on the sizes of those groups.
_______________________________________________________

Approach :
Traverse the string once.
Maintain:
strk → length of current consecutive character group.
prev → length of previous consecutive group.

If the current character equals the previous one:
Increment strk.

Otherwise:
Assign prev = strk.
Reset strk = 1.

At each step:
If strk <= prev, increment the result.
This ensures we only count valid balanced substrings.
We never generate substrings explicitly, we only count them using group sizes.
_______________________________________________________

Complexity :
Time complexity: O(n)
Space complexity: O(1)
