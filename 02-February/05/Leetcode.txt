3379. Transformed Array
You are given an integer array nums that represents a circular array. Your task is to create a new array result of the same size, following these rules:
For each index i (where 0 <= i < nums.length), perform the following independent actions:
If nums[i] > 0: Start at index i and move nums[i] steps to the right in the circular array. Set result[i] to the value of the index where you land.
If nums[i] < 0: Start at index i and move abs(nums[i]) steps to the left in the circular array. Set result[i] to the value of the index where you land.
If nums[i] == 0: Set result[i] to nums[i].

Return the new array result.

Note: Since nums is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.
________________________________________________________

Code :
class Solution {
    public int[] constructTransformedArray(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            ans[i] = nums[((i + nums[i]) % n + n) % n];
        }
        return ans;
    }
}
________________________________________________________

Intuition :
The array is circular, so moving left or right from any index may wrap around the ends. For each index i, we independently compute where we would land after moving nums[i] steps: to the right if positive, to the left if negative, or staying in place if zero. The key idea is to convert this movement into a valid circular index using modular arithmetic, ensuring the index always stays within [0, n-1].
________________________________________________________

Approach :
Let n be the length of the array.

For each index i:
Compute the target index as i + nums[i].
Use modulo n to wrap around the circular array.
Adjust for negative values to ensure the index remains non-negative.

Assign result[i] to the value at the computed index in nums.
Return the resulting array.
________________________________________________________

Complexity :
Time complexity: O(n)
Space complexity: O(n)