3721. Longest Balanced Subarray II
You are given an integer array nums.
A subarray is called balanced if the number of distinct even numbers in the subarray is equal to the number of distinct odd numbers.
Return the length of the longest balanced subarray.
_______________________________________________________

Code :
class SegmentTree {
    int n;
    int[] minTree, maxTree, lazy;

    public SegmentTree(int n) {
        this.n = n;
        minTree = new int[4 * n];
        maxTree = new int[4 * n];
        lazy = new int[4 * n];
    }

    private void push(int node, int start, int end) {
        if (lazy[node] != 0) {
            minTree[node] += lazy[node];
            maxTree[node] += lazy[node];
            if (start != end) {
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    public void updateRange(int node, int start, int end, int l, int r, int val) {
        push(node, start, end);
        if (start > end || start > r || end < l) {
            return;
        }
        if (l <= start && end <= r) {
            lazy[node] += val;
            push(node, start, end);
            return;
        }
        int mid = (start + end) / 2;
        updateRange(2 * node, start, mid, l, r, val);
        updateRange(2 * node + 1, mid + 1, end, l, r, val);
        minTree[node] = Math.min(minTree[2 * node], minTree[2 * node + 1]);
        maxTree[node] = Math.max(maxTree[2 * node], maxTree[2 * node + 1]);
    }

    public int findLeftmostZero(int node, int start, int end) {
        push(node, start, end);
        if (minTree[node] > 0 || maxTree[node] < 0) {
            return -1;
        }
        if (start == end) {
            return minTree[node] == 0 ? start : -1;
        }
        int mid = (start + end) / 2;
        int left = findLeftmostZero(2 * node, start, mid);
        if (left != -1) return left;
        return findLeftmostZero(2 * node + 1, mid + 1, end);
    }
}

public class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length;
        Map<Integer, Integer> prev = new HashMap<>();

        SegmentTree st = new SegmentTree(n);
        int res = 0;

        for (int r = 0; r < n; r++) {
            int v = nums[r];
            int val = (v % 2 == 0) ? 1 : -1;

            if (prev.containsKey(v)) {
                st.updateRange(1, 0, n - 1, 0, prev.get(v), -val);
            }

            st.updateRange(1, 0, n - 1, 0, r, val);
            prev.put(v, r);

            int l = st.findLeftmostZero(1, 0, n - 1);
            if (l != -1 && l <= r) {
                res = Math.max(res, r - l + 1);
            }
        }

        return res;
    }
}
_______________________________________________________

Intuition :
We convert the problem into a prefix-balance problem.
For each new distinct number:
Even → contribute +1
Odd → contribute −1
Define:
balance = #distinct evens - #distinct odds

A subarray is balanced if this balance equals 0 over that subarray.
However, when a number repeats, its previous contribution must be removed from all prefix sums that included it. 

That means we need a structure that can:
Add or subtract a value over a prefix range
Quickly find the leftmost position where balance = 0
A Segment Tree with Lazy Propagation allows:

Range updates in O(log n)
Querying the leftmost index where balance is zero in O(log n)
Thus, we dynamically maintain prefix balances while correcting duplicate contributions.
_______________________________________________________

Approach :
Maintain a map prev[v] storing the last index where value v appeared.
Use a Segment Tree over indices [0..n-1] to maintain prefix balances.

For each index r:
Compute contribution:
Even → +1
Odd → -1

If v appeared before at index p:
Remove its previous contribution from range [0..p]
Add current contribution to range [0..r]
Update prev[v] = r

Query the segment tree to find the leftmost index l where balance = 0.
If such l exists and l ≤ r, update: res = max(res, r - l + 1)

Return res.
_______________________________________________________

Complexity :
Time complexity: O(nlogn)
Space complexity: O(n)